/* 
 * Copyright (c) 2007, Laminar Research.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
 * THE SOFTWARE.
 *
 */

#define HEAVY_CROP_DEBUGGING 0
#define CROP_DIAGNOSTICS 0


/* Stop me if you've heard this one...a mathematician, a physicist and a computer 
   scientist get stuck out in the desert when their car breaks down...
   ...anyway it turnos out that some maps have vertical or horizontal segments
   along the crop border and must be piece-wise cropped.  but piece wise cropping
   for some reason sometimes causes the point locate strategy to lose its shit.   
   So we have a flag to crop piece wise or all at once ,and we run the tool twice
   letting it blow up and try again on some files.
*/
#define USE_PIECEWISE_CROPPING 1

inline	bool	IS_INSIDE(const Point2& pt, const Point2& minp, const Point2& maxp)
{
	return 	(pt.x > minp.x) &&
			(pt.y > minp.y) &&
			(pt.x < maxp.x) &&
			(pt.y < maxp.y);
}

inline bool		IS_OUTSIDE(const Point2& pt, const Point2& minp, const Point2& maxp)
{
	return 	(pt.x < minp.x) ||
			(pt.y < minp.y) ||
			(pt.x > maxp.x) ||
			(pt.y > maxp.y); 				
}

inline bool		IS_ONEDGE(const Point2& pt, const Point2& minp, const Point2& maxp)
{
	return 	!IS_OUTSIDE(pt, minp, maxp) && !IS_INSIDE(pt, minp, maxp);
}

inline bool		IS_EDGEONEDGE(const Point2& a, const Point2& b, const Point2& minp, const Point2& maxp)
{
	// Check the top edge
	if ((a.y == maxp.y) &&
		(b.y == maxp.y) &&
		(a.x >= minp.x) &&
		(a.x <= maxp.x) &&
		(b.x >= minp.x) &&
		(b.x <= maxp.x)) return true;
	// Check the bottom edge
	if ((a.y == minp.y) &&
		(b.y == minp.y) &&
		(a.x >= minp.x) &&
		(a.x <= maxp.x) &&
		(b.x >= minp.x) &&
		(b.x <= maxp.x) ) return true;		

	// Check the right edge
	if ((a.x == maxp.x) == CGAL::EQUAL &&
		(b.x == maxp.x) == CGAL::EQUAL &&
		(a.y >= minp.y) != CGAL::SMALLER &&
		(a.y <= maxp.y) != CGAL::LARGER &&
		(b.y >= minp.y) != CGAL::SMALLER &&
		(b.y <= maxp.y) != CGAL::LARGER) return true;
	// Check the left edge
	if ((a.x == minp.x) &&
		(b.x == minp.x) &&
		(a.y >= minp.y) &&
		(a.y <= maxp.y) &&
		(b.y >= minp.y) &&
		(b.y <= maxp.y)) return true;		
	return false;
}

void	DUMP_CCB(Pmwx::Ccb_halfedge_circulator he, const Point2& sw, const Point2& ne)
{
	Pmwx::Ccb_halfedge_circulator cur = he;
	do { 
		printf("Pt is: %lf,%lf ", 
			cur->target()->point().x,
			cur->target()->point().y);
		if (IS_INSIDE(cur->target()->point(), sw, ne))
			printf(" [INSIDE] \n");
		else if (IS_OUTSIDE(cur->target()->point(), sw, ne))
			printf(" [OUTSIDE] \n");
		else if (IS_ONEDGE(cur->target()->point(), sw, ne))
			printf(" [ON EDGE] \n");
		else
			printf(" [ERROR!!!] \n");
			
		cur++;
	} while (cur != he);
}

bool	CHECK_CCB(Pmwx::Ccb_halfedge_circulator he, const Point2& sw, const Point2& ne)
{
	Pmwx::Ccb_halfedge_circulator cur = he;
	bool	has_inside = false;
	do { 
		if (IS_INSIDE(cur->target()->point(), sw, ne))
		{
			has_inside = true;
			break;
		}
		cur++;
	} while (cur != he);
	if (has_inside)
		DUMP_CCB(he, sw, ne);
	return has_inside;
}

bool	CHECK_FACE(GISFace * fc, const Point2& sw, const Point2& ne)
{
	if (!fc->is_unbounded() && CHECK_CCB(fc->outer_ccb(), sw, ne)) 
	{	
		printf("Face check failed on outer CCB.\n");
		return true;
	}
	for (Pmwx::Holes_iterator h = fc->holes_begin(); h != fc->holes_end(); ++h)
	{
		if (CHECK_CCB(*h, sw, ne)) 
		{
			printf("Face check failed on inner CCB.\n");
			return true;
		}
	}
	return false;
}

void	CHECK_CCB_SPAN(Pmwx::Ccb_halfedge_circulator h, const Point2& sw, const Point2& ne, bool& outside, bool& inside, Point2& ccbmin, Point2& ccbmax)
{
	ccbmin = ccbmax = h->target()->point();
	Pmwx::Ccb_halfedge_circulator cur = h;
	do {
		ccbmin.x = min(ccbmin.x, cur->target()->point().x);
		ccbmax.x = max(ccbmax.x, cur->target()->point().x);
		ccbmin.y = min(ccbmin.y, cur->target()->point().y);
		ccbmax.y = max(ccbmax.y, cur->target()->point().y);

		if (IS_OUTSIDE(cur->target()->point(), sw, ne))
			outside = true;
		if (IS_INSIDE(cur->target()->point(), sw, ne))
			inside = true;
		cur++;
	} while (cur != h);
}

void	CHECK_FACE_SPAN(GISFace * f, const Point2& sw, const Point2& ne, bool check_crossings)
{
	bool	outside = false, inside = false;
	if (f->is_unbounded()) return;
	
	Point2	outermin, outermax;
	
	CHECK_CCB_SPAN(f->outer_ccb(), sw, ne, outside, inside, outermin, outermax);
	if (check_crossings && outside && inside)
	{
		printf("FACE CHECK SPAN FAILED: outer CCB crosses.\n");
		DUMP_CCB(f->outer_ccb(), sw, ne);
	}
	
	bool	face_on_outside = outside;
	
	for (Pmwx::Holes_iterator h = f->holes_begin(); h != f->holes_end(); ++h)
	{
		Point2	innermin, innermax;
		CHECK_CCB_SPAN(*h, sw, ne, outside, inside, innermin, innermax);
		
		if (innermin.x < outermin.x ||
			innermin.y < outermin.y ||
			innermax.x > outermax.x ||
			innermax.y > outermax.y)
		{
			printf("HOLE CONSISTENCY CHECK IN BOUNDING BOX:\n");
			printf("Outer boundary = %lf,%f to %lf, %lf\n", 
				outermin.x,outermin.y,
				outermax.x,outermax.y);
			printf("Inner boundary = %lf,%f to %lf, %lf\n", 
				innermin.x,innermin.y,
				innermax.x,innermax.y);
		}
		
		if (check_crossings && outside && inside)
		{
			if (!face_on_outside) printf("ERROR:Face is on inside!!!\n");
//			printf("FACE CHECK SPAN FAILED: outer CCB and inner CCB not on the same sides!.\n");
//			DUMP_CCB(f->halfedge(), sw, ne);
//			printf("And this is the hole.\n");
//			DUMP_CCB(*h, sw, ne);
		}
	}
}

#if !DEV
class	CropMapNotifier : public Pmwx::Pmwx_change_notification {
public:

	int	mEdgeAdds;
	int	mEdgeSplits;
	int	mFaceSplits;
	int	mOverlaps;
	
	CropMapNotifier() : mEdgeAdds(0), mEdgeSplits(0), mFaceSplits(0), mOverlaps(0) { }
	

	virtual void add_edge(const typename Traits::X_curve & cv, 
	                    typename Planar_map::Halfedge_handle hdl, 
	                    bool original_direction, bool overlap)
	{
		if (hdl->twin()->mDominant)
			printf("WARNING: Handle has already dominant twin.  Overlap = %s\n", overlap ? "true" : "false");
		if (hdl->mDominant && !mOverlaps)
			printf("WARNING: Edge is already dominant...strange!\n");
		++mEdgeAdds;
		hdl->mDominant = true;
		if (overlap) 
			++mOverlaps;
	}

	virtual void split_edge(typename Planar_map::Halfedge_handle orgEdge,
	                      typename Planar_map::Halfedge_handle newEdge,
	                      const typename Traits::X_curve& cv1,
	                      const typename Traits::X_curve& cv2)
	{
		if (orgEdge->mDominant && orgEdge->twin()->mDominant)
			printf("ERR: original edge double dominance.\n");
		if (!orgEdge->mDominant && !orgEdge->twin()->mDominant)
			printf("ERR: original edge zero dominance.\n");
		if (newEdge->mDominant)
			printf("WARNING: Strange - split edge's new edge is dominant.\n");
		if (newEdge->twin()->mDominant)
			printf("WARNING: Strange - split edge's new edge's twin is dominant.\n");
		++mEdgeSplits;
		newEdge->mDominant = orgEdge->mDominant;
		newEdge->mTransition = orgEdge->mTransition;
		// ISSUE: segments really need to be cut and averaged!!
		newEdge->mSegments = orgEdge->mSegments;
		newEdge->mParams = orgEdge->mParams;
		newEdge->mInset = orgEdge->mInset;


		newEdge->twin()->mDominant = orgEdge->twin()->mDominant;
		newEdge->twin()->mTransition = orgEdge->twin()->mTransition;
		// ISSUE: segments really need to be cut and averaged!!
		newEdge->twin()->mSegments = orgEdge->twin()->mSegments;
		newEdge->twin()->mParams = orgEdge->twin()->mParams;
		newEdge->twin()->mInset = orgEdge->twin()->mInset;

		if (newEdge->mDominant && newEdge->twin()->mDominant)
			printf("ERR: original edge double dominance.\n");
		if (!newEdge->mDominant && !newEdge->twin()->mDominant)
			printf("ERR: original edge zero dominance.\n");

	}

	virtual void split_face(typename Planar_map::Face_handle orgFace,
	                      typename Planar_map::Face_handle newFace)
	{
		++mFaceSplits;
//		newFace->mIsWater = orgFace->mIsWater;
		newFace->mTerrainType = orgFace->mTerrainType;
		newFace->mParams = orgFace->mParams;
		// ISSUE: these need to be partitioned based on what side of the 
		// common edge they are on!!
		newFace->mObjs = orgFace->mObjs;
		newFace->mPolyObjs = orgFace->mPolyObjs;
	}

	virtual void add_hole(typename Planar_map::Face_handle in_face, 
	                    typename Planar_map::Halfedge_handle new_hole)
	{
	}
}; 
#endif


void	CropMap(
			Pmwx&			ioMap,
			double			inWest,
			double			inSouth,
			double			inEast,
			double			inNorth)
{
	/***************************************************************
	 * AN ALGORITHM TO CROP PLANAR MAPS IN LINEAR TIME (ISH)
	 ***************************************************************/

//		CropMapNotifier	notifier;

	/**************************************************************
	 * INSERTION OF EDGES TO MAKE THE CROP BOUNDARY
	 **************************************************************/

	Point2		nw(inWest, inNorth);
	Point2		ne(inEast, inNorth);
	Point2		sw(inWest, inSouth);
	Point2		se(inEast, inSouth);

#if !USE_PIECEWISE_CROPPING
	PM_Curve_2	top(nw, ne);
	PM_Curve_2	bottom(sw, se);
	PM_Curve_2	left(sw, nw);
	PM_Curve_2	right(se, ne);
	
	Pmwx::Halfedge_handle h;
	h = ioMap.insert(top, &notifier);		if (!h->mDominant && !h->twin()->mDominant) printf("Err after crop top.\n");
	h = ioMap.insert(bottom, &notifier);	if (!h->mDominant && !h->twin()->mDominant) printf("Err after crop bot.\n");
	h = ioMap.insert(left, &notifier);		if (!h->mDominant && !h->twin()->mDominant) printf("Err after crop lft.\n");
	h = ioMap.insert(right, &notifier);		if (!h->mDominant && !h->twin()->mDominant) printf("Err after crop rgt.\n");
#endif

#if USE_PIECEWISE_CROPPING
	 
	// This isn't as easy as it seems - if we just insert a giant
	// curve and then it turns out a piece of that curve is already in the
	// map, CGAL will have a fit.  Efi says that they are working on fixing
	// this, but for now we will only insert around these curves.
	
	typedef 	map<Kernel::FT, Pmwx::Halfedge_handle>	EdgeMap;
	EdgeMap left_map, right_map, bottom_map, top_map;
	
	// Go through each halfedge - if it is increasing and (vertical or horizontal) and on an
	// extended crop edge, insert it by start value.
	for (Pmwx::Halfedge_iterator he = ioMap.halfedges_begin(); he != ioMap.halfedges_end(); ++he)
	{
		if (he->source()->point() == he->target()->point())
			printf("WARNING: zero length segment.\n");
		if (CGAL::compare_x(sw, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(sw, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_y(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_y(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			left_map.insert(EdgeMap::value_type(he->source()->point().y(), he));
		}
		if (CGAL::compare_x(ne, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(ne, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_y(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_y(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			right_map.insert(EdgeMap::value_type(he->source()->point().y(), he));
		}
		if (CGAL::compare_y(sw, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(sw, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_x(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_x(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			bottom_map.insert(EdgeMap::value_type(he->source()->point().x(), he));
		}
		if (CGAL::compare_y(ne, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(ne, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_x(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_x(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			top_map.insert(EdgeMap::value_type(he->source()->point().x(), he));
		}
	}

	// NOTE: vertices inserted _after_ halfedges so we pick the halfedge if applicable (this is a map, not a multimap, insert does not overwrite)
	for (Pmwx::Vertex_iterator vi = ioMap.vertices_begin(); vi != ioMap.vertices_end(); ++vi)
	{
		if (CGAL::compare_x(vi->point(), sw) == CGAL::EQUAL &&
			CGAL::compare_y(vi->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_y(vi->point(), ne) != CGAL::LARGER)
		{
			left_map.insert(EdgeMap::value_type(vi->point().y(), Pmwx::Halfedge_handle()));
		}			
		if (CGAL::compare_x(vi->point(), ne) == CGAL::EQUAL &&
			CGAL::compare_y(vi->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_y(vi->point(), ne) != CGAL::LARGER)
		{
			right_map.insert(EdgeMap::value_type(vi->point().y(), Pmwx::Halfedge_handle()));
		}			
		if (CGAL::compare_y(vi->point(), sw) == CGAL::EQUAL &&
			CGAL::compare_x(vi->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_x(vi->point(), ne) != CGAL::LARGER)
		{
			bottom_map.insert(EdgeMap::value_type(vi->point().x(), Pmwx::Halfedge_handle()));
		}			
		if (CGAL::compare_y(vi->point(), ne) == CGAL::EQUAL &&
			CGAL::compare_x(vi->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_x(vi->point(), ne) != CGAL::LARGER)
		{
			top_map.insert(EdgeMap::value_type(vi->point().x(), Pmwx::Halfedge_handle()));
		}			
	}

#if CROP_DIAGNOSTICS	
	printf("Left table.\n");
	for (EdgeMap::iterator i = left_map.begin(); i != left_map.end(); ++i)
	{
		if (i->second == Pmwx::Halfedge_handle())
			printf("   Got %.6lf    <null>\n", i->first));
		else
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
					i->second->source()->point().x,i->second->source()->point().y,
					i->second->target()->point().x,i->second->target()->point().y);
	}
	printf("Right table.\n");
	for (EdgeMap::iterator i = right_map.begin(); i != right_map.end(); ++i)
	{
		if (i->second == Pmwx::Halfedge_handle())
			printf("   Got %.6lf    <null>\n", i->first));
		else
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
					i->second->source()->point().x,i->second->source()->point().y,
					i->second->target()->point().x,i->second->target()->point().y);
	}
	printf("Bottom table.\n");
	for (EdgeMap::iterator i = bottom_map.begin(); i != bottom_map.end(); ++i)
	{
		if (i->second == Pmwx::Halfedge_handle())
			printf("   Got %.6lf    <null>\n", i->first));
		else
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
				i->second->source()->point().x,i->second->source()->point().y,
				i->second->target()->point().x,i->second->target()->point().y);
	}
	printf("Top table.\n");
	for (EdgeMap::iterator i = top_map.begin(); i != top_map.end(); ++i)
	{
		if (i->second == Pmwx::Halfedge_handle())
			printf("   Got %.6lf    <null>\n", i->first));
		else
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
					i->second->source()->point().x,i->second->source()->point().y,
					i->second->target()->point().x,i->second->target()->point().y);
	}
#endif	

	// This is NOT maximally efficient - we don't use lower bound for a log-N search.  There are
	// very few of these edges in the maps we've seen so far, so this is easier.
	Kernel::FT	last_end = inSouth, final = inNorth;	
	for (EdgeMap::iterator i = left_map.begin(); i != left_map.end(); ++i)
	{
		Kernel::FT	next_start = i->first;
		if (last_end < next_start)
		{
			if (next_start > final) {
				if (last_end < final) {
#if CROP_DIAGNOSTICS
					printf("Inserting final from %.6lf,%.6lf->%.6lf,%.6lf\n",	inWest, last_end),inWest,final));
#endif					
					ioMap.insert(PM_Curve_2(Point2(inWest, last_end), Point2(inWest, final)), &notifier);
					if (i->second != Pmwx::Halfedge_handle())
						last_end = i->second->target()->point().y();
					else
						last_end = final;
				}
				break;
			} else {
#if CROP_DIAGNOSTICS
				printf("Inserting segment from %.6lf,%.6lf->%.6lf,%.6lf\n",	inWest, last_end),inWest,next_start));
#endif				
				ioMap.insert(PM_Curve_2(Point2(inWest, last_end), Point2(inWest, next_start)), &notifier);
				if (i->second != Pmwx::Halfedge_handle())
					last_end = i->second->target()->point().y();
				else
					last_end = next_start;
			}
		} else if (i->second != Pmwx::Halfedge_handle() && i->second->target()->point().y() > last_end)
			last_end = i->second->target()->point().y();
	}
	if (last_end < final)
	{
#if CROP_DIAGNOSTICS
		printf("Inserting remainder from %.6lf,%.6lf->%.6lf,%.6lf\n",	inWest, last_end),inWest,final));
#endif		
		ioMap.insert(PM_Curve_2(Point2(inWest, last_end), Point2(inWest, final)), &notifier);
	}

	
	last_end = inSouth, final = inNorth;	
	for (EdgeMap::iterator i = right_map.begin(); i != right_map.end(); ++i)
	{
		Kernel::FT	next_start = i->first;
		if (last_end < next_start)
		{
			if (next_start > final) {
				if (last_end < final) {
#if CROP_DIAGNOSTICS
					printf("Inserting final from %.6lf,%.6lf->%.6lf,%.6lf\n",	inEast, last_end),inEast,final));
#endif					
					ioMap.insert(PM_Curve_2(Point2(inEast, last_end), Point2(inEast, final)), &notifier);
					if (i->second != Pmwx::Halfedge_handle())
						last_end = i->second->target()->point().y();
					else
						last_end = final;
				}
				break;
			} else {
#if CROP_DIAGNOSTICS
				printf("Inserting segment from %.6lf,%.6lf->%.6lf,%.6lf\n",	inEast, last_end),inEast,next_start));
#endif				
				ioMap.insert(PM_Curve_2(Point2(inEast, last_end), Point2(inEast, next_start)), &notifier);
				if (i->second != Pmwx::Halfedge_handle())
					last_end = i->second->target()->point().y();
				else
					last_end = next_start;
			}
		} else if (i->second != Pmwx::Halfedge_handle() && i->second->target()->point().y() > last_end)
			last_end = i->second->target()->point().y();
	}
	if (last_end < final)
	{
#if CROP_DIAGNOSTICS	
		printf("Inserting remainder from %.6lf,%.6lf->%.6lf,%.6lf\n",	inEast, last_end),inEast,final));
#endif		
		ioMap.insert(PM_Curve_2(Point2(inEast, last_end), Point2(inEast, final)), &notifier);
	}
	

	last_end = inWest, final = inEast;	
	for (EdgeMap::iterator i = bottom_map.begin(); i != bottom_map.end(); ++i)
	{
		Kernel::FT	next_start = i->first;
		if (last_end < next_start)
		{
			if (next_start > final) {
				if (last_end < final) {
#if CROP_DIAGNOSTICS
					printf("Inserting final from %.6lf,%.6lf->%.6lf,%.6lf\n",	last_end),inSouth,final),inSouth);
#endif					
					ioMap.insert(PM_Curve_2(Point2(last_end, inSouth), Point2(final, inSouth)), &notifier);
					if (i->second != Pmwx::Halfedge_handle())
						last_end = i->second->target()->point().x();
					else
						last_end = final;
				}
				break;
			} else {
#if CROP_DIAGNOSTICS
				printf("Inserting segment from %.6lf,%.6lf->%.6lf,%.6lf\n",	last_end),inSouth,next_start),inSouth);
#endif				
				ioMap.insert(PM_Curve_2(Point2(last_end, inSouth), Point2(next_start, inSouth)), &notifier);
				if (i->second != Pmwx::Halfedge_handle())
					last_end = i->second->target()->point().x();
				else
					last_end = next_start;
			}
		} else if (i->second != Pmwx::Halfedge_handle() && i->second->target()->point().x() > last_end)
			last_end = i->second->target()->point().x();
	}
	if (last_end < final)
	{
#if CROP_DIAGNOSTICS
		printf("Inserting remainder from %.6lf,%.6lf->%.6lf,%.6lf\n",	last_end),inSouth,final),inSouth);
#endif		
		ioMap.insert(PM_Curve_2(Point2(last_end, inSouth), Point2(final, inSouth)), &notifier);
	}
		
	
	last_end = inWest, final = inEast;	
	for (EdgeMap::iterator i = top_map.begin(); i != top_map.end(); ++i)
	{
		Kernel::FT	next_start = i->first;
		if (last_end < next_start)
		{
			if (next_start > final) {
				if (last_end < final) {
#if CROP_DIAGNOSTICS
					printf("Inserting final from %.6lf,%.6lf->%.6lf,%.6lf\n",	last_end),inNorth,final),inNorth);
#endif					
					ioMap.insert(PM_Curve_2(Point2(last_end, inNorth), Point2(final, inNorth)), &notifier);
					if (i->second != Pmwx::Halfedge_handle())
						last_end = i->second->target()->point().x();
					else
						last_end = final;
				}
				break;
			} else {
#if CROP_DIAGNOSTICS			
				printf("Inserting segment from %.6lf,%.6lf->%.6lf,%.6lf\n",	last_end),inNorth,next_start),inNorth);
#endif				
				ioMap.insert(PM_Curve_2(Point2(last_end, inNorth), Point2(next_start, inNorth)), &notifier);
				if (i->second != Pmwx::Halfedge_handle())
					last_end = i->second->target()->point().x();
				else
					last_end = next_start;
			}
		} else if (i->second != Pmwx::Halfedge_handle() && i->second->target()->point().x() > last_end)
			last_end = i->second->target()->point().x();
	}
	if (last_end < final)
	{
#if CROP_DIAGNOSTICS
		printf("Inserting remainder from %.6lf,%.6lf->%.6lf,%.6lf\n",	last_end),inNorth,final),inNorth);
#endif		
		ioMap.insert(PM_Curve_2(Point2(last_end, inNorth), Point2(final, inNorth)), &notifier);
	}
	
	
	
	
	
#if CROP_DIAGNOSTICS	
	
	
	left_map.clear();
	right_map.clear();
	bottom_map.clear();
	top_map.clear();
	
	for (Pmwx::Halfedge_iterator he = ioMap.halfedges_begin(); he != ioMap.halfedges_end(); ++he)
	{
		if (CGAL::compare_x(sw, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(sw, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_y(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_y(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			left_map.insert(EdgeMap::value_type(he->source()->point().y(), he));
		}
		if (CGAL::compare_x(ne, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(ne, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_y(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_y(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			right_map.insert(EdgeMap::value_type(he->source()->point().y(), he));
		}
		if (CGAL::compare_y(sw, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(sw, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_x(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_x(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			bottom_map.insert(EdgeMap::value_type(he->source()->point().x(), he));
		}
		if (CGAL::compare_y(ne, he->source()->point()) == CGAL::EQUAL &&
			CGAL::compare_y(ne, he->target()->point()) == CGAL::EQUAL &&
			CGAL::compare_x(he->target()->point(), sw) != CGAL::SMALLER &&
			CGAL::compare_x(he->source()->point(), ne) != CGAL::LARGER &&
			CGAL::compare_x(he->source()->point(), he->target()->point()) == CGAL::SMALLER)
		{
			top_map.insert(EdgeMap::value_type(he->source()->point().x(), he));
		}
	}
	
	printf("Left table\n");
	for (EdgeMap::iterator i = left_map.begin(); i != left_map.end(); ++i)
	{
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
					i->second->source()->point().x,i->second->source()->point().y,
					i->second->target()->point().x,i->second->target()->point().y);
	}
	printf("Right table.\n");
	for (EdgeMap::iterator i = right_map.begin(); i != right_map.end(); ++i)
	{
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
					i->second->source()->point().x,i->second->source()->point().y,
					i->second->target()->point().x,i->second->target()->point().y);
	}
	printf("Bottom table.\n");
	for (EdgeMap::iterator i = bottom_map.begin(); i != bottom_map.end(); ++i)
	{
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
					i->second->source()->point().x,i->second->source()->point().y,
					i->second->target()->point().x,i->second->target()->point().y);
	}
	printf("Top table.\n");
	for (EdgeMap::iterator i = top_map.begin(); i != top_map.end(); ++i)
	{
		printf("   Got %.6lf    %.6lf,%.6lf->%.6lf,%.6lf\n", i->first),
					i->second->source()->point().x,i->second->source()->point().y,
					i->second->target()->point().x,i->second->target()->point().y);
	}
	

	if (!ioMap.is_valid())
		printf("Map already broken!\n");
#endif

#endif /* USE_PIECEWISE_CROPPING */
		
//	printf("%d splits, %d new edges, %d overlaps.\n", notifier.mEdgeSplits, notifier.mEdgeAdds, notifier.mOverlaps);
//	if (!ValidateMapDominance(ioMap)) printf("Dominance broken after insert of cut lines.\n");
		
	Dcel&	dcel = ioMap.GetDcel();

#if HEAVY_CROP_DEBUGGING
	printf("Checking faces for a crossing.\n");
	for (Dcel::Face_iterator fc = dcel.faces_begin(); fc != dcel.faces_end(); ++fc)
		CHECK_FACE_SPAN(&*fc, sw, ne, false);
	printf("Checking done. Splitting.\n");
#endif
	
#if HEAVY_CROP_DEBUGGING
	printf("Split done, checking again...\n");

	// PRECONDITION SANITY CHECK - ANY FACES SPANNING THE REGIONS?!?  If so we're FUCKED
	for (Dcel::Face_iterator fc = dcel.faces_begin(); fc != dcel.faces_end(); ++fc)
	{
		CHECK_FACE_SPAN(&*fc, sw, ne, true);
	}
	printf("Done checking post-split.\n");
#endif
	/*********** PART 1 - PREPARATION ***************/
	
	// We will work up a set of elements that all must be killed.
	set<Dcel::Vertex *>		deadVertex;
	set<Dcel::Halfedge *>	deadHalfedge;
	set<Dcel::Halfedge *>	borderHalfedge;	// For debugging
	set<Dcel::Vertex *>		borderVertex;
	set<Dcel::Face *>		deadFace;
	
	// Also for halfedges that are on the outside border (e.g. will
	// make up the single hole of the unbounded face) we will use
	// a table, from the source vertex to the halfedge.
	map<Dcel::Vertex *, Dcel::Halfedge *>	borderMap;

	Dcel::Face *			unbounded = NULL;

	// Go through each halfedge...if its vertex is outside the area then we know that:
	// 1. It needs to be nuked, and its twin does too.
	// 2. The vertex it points to needs to be nuked.
	// 3. The faces for both halfedges need to be nuked UNLESS they're the unbounded face
	
	for (Dcel::Vertex_iterator vi = dcel.vertices_begin(); vi != dcel.vertices_end(); ++vi)
	{
		if (!IS_OUTSIDE(vi->point(), sw, ne) && !IS_INSIDE(vi->point(), sw, ne))
		{
			borderVertex.insert(&*vi);
		}
	}
	for (Dcel::Halfedge_iterator hi = dcel.halfedges_begin(); hi != dcel.halfedges_end(); ++hi)
	{
		if (hi->face()->halfedge() == NULL)
		{
			if (unbounded == NULL)
				unbounded = hi->face();
			else if (unbounded != hi->face())
				printf("ASSERTION FAILED: TWO DIFFERENT UNBOUNDED FACES!\n");
		}
		
		if (IS_OUTSIDE(hi->vertex()->point(), sw, ne))
		{
			Dcel::Vertex * target = hi->vertex();
			Dcel::Vertex * source = hi->opposite()->vertex();
			if (IS_INSIDE(source->point(), sw, ne))
			{
				printf("ASSERTION FAIL: THIS EDGE SPANS THE CROSSING!  OH NO!\n");
				printf("Crop was: %lf,%lf -> %lf, %lf\n", inWest, inSouth, inEast, inNorth);
				printf("Edge was: %lf,%lf -> %lf, %lf\n", 
					source->point().x,
					source->point().y,
					target->point().x,
					target->point().y);				
			}

#if HEAVY_CROP_DEBUGGING
			// SANITY CHECK: since both faces are being added, neither must be inside!!
			if (CHECK_FACE(hi->face(), sw, ne))
			{
				printf("ASSERTION FAIL: the above polygon is marked for death.  Our point was: %lf, %lf\n", 
					hi->vertex()->point().x,	hi->vertex()->point().y);
			}
			
			if (CHECK_FACE(hi->opposite()->face(), sw, ne))
			{
				printf("ASSERTION FAIL: the above polygon is marked for death.  Our point was: %lf, %lf\n", 
					hi->vertex()->point().x,	hi->vertex()->point().y);
			}
#endif			
			
			deadHalfedge.insert(&*hi);
			deadHalfedge.insert(hi->opposite());
			
			if (hi->face()->halfedge())	// In DCEL-land, a NULL halfedge on a face indicates the unbounded face.
				deadFace.insert(hi->face());
			if (hi->opposite()->face()->halfedge())
				deadFace.insert(hi->opposite()->face());			
			deadVertex.insert(hi->vertex;
		}
	}
	
#if HEAVY_CROP_DEBUGGING	
	// SANITY CHECK - all halfedges need to be on the deadlist WITH THEIR TWIN or we're in deep deep shizemŸnchen
	for (Dcel::Halfedge_iterator hi = dcel.halfedges_begin(); hi != dcel.halfedges_end(); ++hi)
	{
		if (deadHalfedge.find(&*hi) != deadHalfedge.end())
		{
			// We're dead, our twin MUST be!
			if (deadHalfedge.find(hi->opposite()) == deadHalfedge.end())
				printf("ERROR: MISMATCHED HALFEDGES IN THE DEAD QUEUE!\n");
		} else {
			if (deadHalfedge.find(hi->opposite()) != deadHalfedge.end())
				printf("ERROR: MISMATCHED HALFEDGES IN THE DEAD QUEUE!\n");
		}
	}
#endif
	
#if HEAVY_CROP_DEBUGGING	
	// SANITY CHECK - NO DEAD FACES SHOULD HAVE INTERIOR PTS
	for (set<Dcel::Face *>::iterator dfi = deadFace.begin(); dfi != deadFace.end(); ++dfi)
	{
		bool ok = true;
		Dcel::Halfedge * cur = (*dfi)->halfedge(), * edge  = (*dfi)->halfedge();
		do {
			Dcel::Vertex * p = cur->vertex();
			if (IS_INSIDE(p->point(), sw, ne))
			{
				ok = false;
				printf("ASSERTION FAIL: DEAD FACE HAS INTERIOR PT!  OH NO!\n");
				printf("Crop was: %lf,%lf -> %lf, %lf\n", inWest, inSouth, inEast, inNorth);
				printf("Pt was: %lf,%lf ", 
					p->point().x,
					p->point().y);				
			}
			
			cur = cur->next();
		} while (cur != edge);
		
		if (!ok)	
			DUMP_CCB((*dfi)->halfedge(), sw, ne);
	}
#endif
	
	if (unbounded == NULL)
		printf("ASSERTION FAILURE: DIDN'T FIND UNBOUNDED FACE!\n");
	
	// Now that we have our collection of dead faces we can rapidly identify what will become 
	// the new outer of the map.  In particular, given two halfedges that are twins and are on the edge,
	// only the one whose face is either unbounded or dead will form a border.
	for (Dcel::Halfedge_iterator hi = dcel.halfedges_begin(); hi != dcel.halfedges_end(); ++hi)
	{
		Dcel::Vertex * target = hi->vertex();
		Dcel::Vertex * source = hi->opposite()->vertex();
		// If both points on the halfedge are on the edge, then this is a boundary case.
		if (IS_EDGEONEDGE(source->point(), target->point(), sw, ne))
		{			
			if (deadFace.find(hi->face()) != deadFace.end() ||
				hi->face()->halfedge() == NULL)
			{
				bool	we_infinite = hi->face()->halfedge() == NULL;
				bool	fail = false;

				if (hi->face() == hi->opposite()->face())
					fail = true, printf("ASSERTION FAILED: BORDER FACE IS AN ANTENNA!\n");

				// Make sure our idea of what our face is doing is consistent.
				if (we_infinite && deadFace.find(hi->face()) != deadFace.end())
					fail = true, printf("ASSERTION FAILED: OUR FACE IS DEAD AND IS THE UNBOUNDED FACE! (Our face is found unbounded? %s", (hi->face() == unbounded) ? "yes" : "no");
					
				// Make sure our halfedge is not already dead, that'd indicate a failure in my CGAL compare crap.
				if (deadHalfedge.find(&*hi) != deadHalfedge.end())
					fail = true, printf("ASSERTION FAILURE: DEAD HALFEDGE IS A BORDER HALFEDGE!\n");
				if (deadHalfedge.find(hi->opposite()) != deadHalfedge.end())
					fail = true, printf("ASSERTION FAILURE: DEAD HALFEDGE IS A BORDER HALFEDGE'S TWIN!\n");

				// We really don't expect our twin's face to make it elligible for border-dom!
				if (deadFace.find(hi->opposite()->face()) != deadFace.end())
					fail = true, printf("ASSERTION FAILURE: BORDER HALFEDGE'S TWIN IS IN DEAD LIST! (Our face infinite? %s)\n", we_infinite ? "yes" : "no");
				if (hi->opposite()->face()->halfedge() == NULL)
					fail = true, printf("ASSERTION FAILURE: BORDER HALFEDGE'S TWIN IS THE UNBOUNDED FACE! (Our face infinite? %s)\n", we_infinite ? "yes" : "no");

				// Make sure that our twin is not a border - that'd be bad.
				if (borderHalfedge.find(hi->opposite()) != borderHalfedge.end())
					fail = true, printf("ASSERTION FAILURE: WE ARE BORDER BUT OUR TWIN ALREADY IS.\n");

				// Make sure this is the only instance of the source vertex on the border list - only one
				// halfedge should start at a given vertex on the border!
				if (borderMap.find(source) != borderMap.end())
					fail = true, printf("ASSERTION FAILURE: SOURCE ON HALFEDGE ALREADY HAS A HALFEDGE!\n");

				borderHalfedge.insert(&*hi);
				borderMap.insert(map<Dcel::Vertex *, Dcel::Halfedge *>::value_type(source, &*hi));
				
				if (fail)
				{
					printf("Crop was: %lf,%lf -> %lf, %lf\n", inWest, inSouth, inEast, inNorth);
					printf("Edge was: %lf,%lf -> %lf, %lf\n", 
						source->point().x,
						source->point().y,
						target->point().x,
						target->point().y);
					
					printf("Our face is dead? %s\n", (deadFace.find(hi->face()) != deadFace.end()) ? "yes" : "no");
					printf("Our face is: 0x%08X\n", hi->face());
					DUMP_CCB(&*hi, sw, ne);
					printf("Our opp face is dead? %s\n", (deadFace.find(hi->opposite()->face()) != deadFace.end()) ? "yes" : "no");
					printf("Our opp face is: 0x%08X\n", hi->opposite()->face());
					DUMP_CCB(hi->opposite(), sw, ne);
				}
			}
		}
	}
	
	/************* PART 2 - COMPLETE DESTRUCTION - MUAHUAHUAHUA *****************/
	
	for (set<Dcel::Halfedge *>::iterator he = deadHalfedge.begin(); he != deadHalfedge.end(); ++he)
		dcel.delete_halfedge(*he);
	for (set<Dcel::Vertex *>::iterator ve = deadVertex.begin(); ve != deadVertex.end(); ++ve)
		dcel.delete_vertex(*ve);
	for (set<Dcel::Face *>::iterator fe = deadFace.begin(); fe != deadFace.end(); ++fe)
		dcel.delete_face(*fe);

	// The border map goes from a vertex to a halfedge that has it as its source.
	// The halfedge knows its target.	
#if CROP_DIAGNOSTICS
#if USE_PIECEWISE_CROPPING
	printf("Top: %d Bot %d Left %d right %d\n", top_map.size(), bottom_map.size(), left_map.size(), right_map.size());
#endif
	printf("Border map has %d segments\n", borderMap.size());
	printf("Starting: %d border vertices.\n", borderVertex.size());
#endif	

	for (map<Dcel::Vertex *, Dcel::Halfedge *>::iterator bi = borderMap.begin(); bi != borderMap.end(); ++bi)
	{
		bi->second->set_face(unbounded);
		// My next halfedge is the one whose source is my vertex.
		map<Dcel::Vertex *, Dcel::Halfedge *>::iterator next = borderMap.find(bi->second->vertex());
		if (next == borderMap.end())
			printf("ASSERTION FAILED: COULD NOT FIND NEXT LINK!");
		else {
			bi->second->set_next(next->second);
			if (next->second->opposite()->vertex() != bi->second->vertex())
				printf("Warning: something is broken.\n");
		}
		// Special fix - it's possible that a vertex on the edge defined its surroundings via a halfedge
		// that we nuked.  So make sure that this vertex points to us, so we can be legit.
		bi->second->vertex()->set_halfedge(bi->second);
		borderVertex.erase(bi->second->vertex());
	}

#if CROP_DIAGNOSTICS	
	printf("Remaining: %d border vertices.\n", borderVertex.size());
#endif	
	for (set<Dcel::Vertex *>::iterator i = borderVertex.begin(); i != borderVertex.end(); ++i)
	{
		printf("ERROR: Remaining vertex is %.6lfx%.6lf\n", (*i)->point().x,(*i)->point().y);
	}
	unbounded->erase_holes(unbounded->holes_begin(), unbounded->holes_end());
	if (!borderMap.empty())
		unbounded->add_hole(borderMap.begin()->second);
		
		
#if CROP_DIAGNOSTICS		
	// Final post check
	int c = 0;
	for (Pmwx::Vertex_handle h = ioMap.vertices_begin(); h != ioMap.vertices_end(); ++h)
	{
		if (h->halfedge()->vertex() != &*h)
			++c;
	}
	printf("%d misaligned vertices.\n");
#endif	
}